#+TITLE: Web Plotter - Plotting from Incanter to Websites
#+AUTHOR: Nils Blum-Oeste
#+EMAIL: nils@blum-oeste.de
#+LANGUAGE: en
#+STARTUP: align hidestars lognotestate
#+INFOJS_OPT: view:info toc:nil
#+HTML_HEAD: <script src="http://code.jquery.com/jquery-2.1.3.min.js"></script>
#+HTML_HEAD: <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/monokai.min.css">
#+HTML_HEAD: <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
#+HTML_HEAD: <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/languages/clojure.min.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="resources/htmlize.css" />
#+HTML_HEAD: <script src="resources/export.js"></script>
#+OPTIONS: :html-include-style t

* Introduction
  This is my first try with literate programming. I am going to do some simple plotting with Incanter to HTML using NVD3
  and following the Clojure Data Analysis Cookbook.

** Literate Programming Example

   Here is a plain simple example for Literate Programming. The application code is included in this document. Via
   "tangling" the application's source code files are generated. Output from instructions can also be included in this
   document, as this example shows:

   #+BEGIN_SRC clojure :exports both
     (+ 1 1)
   #+END_SRC

   #+RESULTS:
   : 2

* Leiningen Project

** Project definition

   #+BEGIN_SRC clojure :tangle project.clj
   (defproject web-plotter "0.1.0-SNAPSHOT"
     :description "plotting with Incanter and NVD3"
     :url "http://example.com/FIXME"
     :license {:name "Eclipse Public License"
               :url "http://www.eclipse.org/legal/epl-v10.html"}
     :dependencies [[org.clojure/clojure "1.6.0"]
                    [ring/ring-core "1.3.2"]
                    [ring/ring-jetty-adapter "1.3.2"]
                    [compojure "1.3.1"]
                    [hiccup "1.0.5"]
                    [org.clojure/clojurescript "0.0-2760"]]
     :plugins [[lein-ring "0.9.1"]
               [lein-cljsbuild "1.0.4"]]
     :ring {:handler web-plotter.server/app}
     :cljsbuild {:builds
                 [{:source-paths ["src-cljs"]
                   :compiler
                   {:output-to "resources/js/main.js"
                    :optimizations :whitespace
                    :pretty-print true}}]})
   #+END_SRC

** README

** License note

* Application

** core

   #+BEGIN_SRC clojure :tangle src/web_plotter/core.clj
     (ns web-plotter.core)
   #+END_SRC

   #+RESULTS:

** Server

   The backend application.

***  Namespace setup

    #+BEGIN_SRC clojure :tangle src/web_plotter/server.clj
    (ns web-plotter.server
      (:require [compojure.route :as route]
                [compojure.handler :as handler]
                [clojure.string :as str])
      (:use compojure.core
            ring.adapter.jetty
            [ring.middleware.content-type :only (wrap-content-type)]
            [ring.middleware.file :only (wrap-file)]
            [ring.middleware.file-info :only (wrap-file-info)]
            [ring.middleware.stacktrace :only (wrap-stacktrace)]
            [ring.util.response :only (redirect)]
            [hiccup core element page]
            [hiccup.middleware :only (wrap-base-url)]))
    #+END_SRC

    Ring is used via jetty for handling HTTP requests and Compojure for routing. ([[*Ring concepts][Ring concepts]])
    Hiccup renders Clojure data structures to HTML.


*** Index page

    Rendering an index page via Hiccup. The provided Clojure datastructure is mapped to HTML and should be easy to
    understand.

    #+BEGIN_SRC clojure :tangle src/web_plotter/server.clj
    (defn index-page []
      (html5
        [:head
         [:title "Web Plotter"]]
        [:body
         [:h1 {:id "web-plotter"} "Web Plotter"]
         [:ol
          [:li [:a {:href "/data.json"} "Some example data"]]]
         (include-js "js/main.js")
         (javascript-tag "web_plotter.core.hello('from me ');")]))
    #+END_SRC

*** Routes
    Define the routes of the server via Compojure.

    The Compojure DSL allows to compose routes into a single Ring application handler. Common route definitions include
    the HTTP verb, a path, parameters and a response.

     #+BEGIN_SRC clojure :tangle src/web_plotter/server.clj
       (defroutes
         site-routes
         (GET "/" [] (index-page))
         (route/resources "/")
         (route/not-found "Page not found"))
     #+END_SRC

    - The root path will be redirected to the json data.
    - The resources directory gets served as static files from the web server root path.
    - If no matching route is found, return an error message.

*** Specify request handling

     Set up the app request handler which was build with Compojure. Middlewares for serving static files, adding file
     info and setting content-type headers are wrapped around the handler.

     #+BEGIN_SRC clojure :tangle src/web_plotter/server.clj
       (def app
         (-> (handler/site site-routes)
           (wrap-file "resources")
           (wrap-file-info)
           (wrap-content-type)))
     #+END_SRC


** Client
   #+BEGIN_SRC clojure :tangle src-cljs/web_plotter/core.cljs
   (ns web-plotter.core)

   (defn ^:export hello [world]
     (js/alert (str "Hello " world)))

   #+END_SRC
* Data

  Some hardcoded dummy data to use for plotting.

  #+BEGIN_SRC js :tangle resources/data.json
    { "set1":
      {
        "x": [1, 2, 3],
        "y": [4,5,6]
      }
    }
  #+END_SRC
* Appendix
** Ring concepts
   - Handlers :: Ring handlers are Clojure functions taking a map representing the HTTP requests as an argument and
        return a map representing the HTTP response. Thus handlers transform requests into repsonses.
        ([[https://github.com/ring-clojure/ring/wiki/Concepts#requests][Request Map Reference]], [[https://github.com/ring-clojure/ring/wiki/Concepts#responses][Response Map Reference]]).

   - Middleware :: Middleware are higher order functions taking a handler as an argument and returning a new,
        transformed handler. Middleware extends the handling of raw HTTP requests to add functionalities like request
        parameters, sessions, file uploading etc.

        Middleware example:
        #+BEGIN_SRC clojure
        ;; defining the middleware
        (defn wrap-content-type [handler content-type]
          (fn[request]
            (let [response (handler request)]
              (assoc-in response [:headers "Content-Type"] content-type))))

        ;; wrapping the middleware around a handler
        (def app (wrap-content-type handler "text/html"))
        #+END_SRC

   - Adapters :: Adapters connect Ring to web servers like Jetty, http-kit, etc.
